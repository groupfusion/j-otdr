# OTDR（光时域反射计）数据格式 - sid5432/pubOTDR Wiki

*（最后修订于 2016-01-04）*

> 这是我博客[发布](https://morethanfootnotes.blogspot.com/2015/07/the-otdr-optical-time-domain.html?view=sidebar)的旧副本（自 2016 年 1 月 4 日起） 。自上次更新以来，发生了一些重大变化和更正。请参阅我的博客文章以获取最新版本。

## 介绍

SOR（“标准 OTDR 记录”）数据格式用于存储 OTDR[光时域反射计](http://https//en.wikipedia.org/wiki/Optical_time-domain_reflectometer)光纤数据。该格式由 Telcordia [SR-4731 第 2 版](http://telecom-info.telcordia.com/site-cgi/ido/docs.cgi?ID=SEARCH&DOCUMENT=SR-4731&)标准定义。虽然它是一个标准，但遗憾的是它不是开放的，因为数据格式的细节不是公开的。您可以以 750 美元的价格从 Telcordia 购买标准文档（在撰写本文时），但这对我的预算来说太高了。（并且可能附带各种许可限制。我不知道；我从未见过该文件！）

有几个免费提供的 OTDR 跟踪阅读器可以从网上下载，但大多数都不允许将跟踪数据导出到 CSV 文件中以供进一步分析，而且我知道只有一个可以在 Linux 上本地运行（尽管有些将与 Wine 模拟器一起使用）。各种 Internet 论坛上都有请求询问有关如何提取跟踪数据的信息，但我不知道有人提供任何答案，除了指向免费阅读器和 Telcordia 标准。

幸运的是，数据格式并不是特别难以破译。Telcordia [SR-4731 第 2 期](http://telecom-info.telcordia.com/site-cgi/ido/docs.cgi?ID=SEARCH&DOCUMENT=SR-4731&)页面上的目录提供了一些线索，[光学时域反射](http://https//en.wikipedia.org/wiki/Optical_time-domain_reflectometer)仪的维基百科页面也是如此。使用二进制文件编辑器/查看器并比较一些免费的 OTDR SOR 文件阅读器的输出，我能够拼凑 SOR 数据格式的大部分编码。在本文中，我将描述我的发现，希望对其他人有用。但是**使用它需要您自担风险**！此处提供的信息基于对有限数量的示例文件的猜测工作。我不能保证没有错误，或者我已经发现了我从示例文件中推断出的规则的所有可能的例外情况。*你被警告了！*

## 一个简单的 SOR 文件阅读器

对于不耐烦的人，我编写了一个简单的程序[pubOTDR](https://github.com/sid5432/pubOTDR)（托管在[GitHub 上](https://github.com/)），它解析 SOR 文件并将跟踪曲线转储到 TAB 分隔的数据文件中。该程序是用 Perl 编写的，效率很低，但它应该可以工作！有一天我可能会写一个 Python 版本，但同时欢迎您将代码移植到对您更有用的任何编程语言。

要运行程序（在 Linux 中），请打开终端并运行程序：

```
  % read_otdr.pl my_otdr_file.sor
```

其中**my_otdr_file.sor**是 OTDR SOR 文件。它将在屏幕上打印解析的信息并将跟踪数据转储到文件**my_otdr_file-trace.dat**中。

## SOR 文件的组织结构

OTDR SOR 文件实际上有两个主要版本。早期版本来自 Bellcore（1.x 版本），新版本是 2.x。这些文件是二进制数据文件；**所有值都被编码为 little-endian 有符号或无符号整数**，浮点值表示为缩放整数（即，整数乘以某个因子，通常是 10 的某个幂，以成为实际值）。不使用浮点数，

*在这两个版本中，数据都是按块*排列的；有些是必需的，有些是可选的。他们是：

- *地图块*（必需）：`Map`
- *通用参数块*（必需）：`GenParams`
- *供应商参数块*（必需）：`SupParams`
- *固定参数块*（必需）：`FxdParams`
- *关键事件块*（如果数据点块不存在则需要）：`KeyEvents`
- *链接参数块*（可选）：`LnkParams`
- *数据点块*（如果不存在关键事件块，则需要）：`DataPts`
- *特殊专有块*（可选）：这些似乎是特定于供应商的。
- *校验和块*（可选）：`Cksum`

Map 块是第一个块，包含格式版本号和要遵循的块的详细信息。文件中的各个块都由其自己的“映射”描述，该映射由块的名称（字符串）、版本号和块的大小（以字节为单位）组成。这些“地图”还指定了块在文件中出现的顺序；订单可能因供应商而异。但是，校验和块始终显示为最后一个块，这种安排对于创建并在计算后附加文件的校验和是有意义的。

在 Map 块之后是包含实际数据的各个块，按照 Map 块中描述的顺序。

旧的 1.x 版本和新的 2.x 版本之间的一个区别是新的 2.x 版本中的块前面有块的名称（例如，GenParams），而旧版本没有。前面的块名称是多余的，但它提供了额外的完整性检查层。

## Map 块

在较新的 2.x 版本中，Map 块以字符串“Map”开头，后跟一个终止字符“\0”。较旧的 1.x 版本没有“Map\0”标题。'Map\0' 标题后面有 8 个字节（在 1.x 版本中，只有 8 个字节）。这些都是：

- 0-1：版本号
- 2-5：Map块中的字节数
- 6-7：块数

所有数字都是无符号整数（回想一下，所有数字都是小端序）。版本号编码为版本号的 100 倍。例如，版本 1.10 将被编码为数字 110。 Map 块中包含的字节数包括“Map\0”标头和随后的 8 字节信息。

8 字节信息后面是要跟随的块的各个“映射”。每个块“映射”由块名称（以 '\0' 字符结尾的字符串）和后跟 6 个字节组成。这 6 个字节是：

- 0-1：版本号
- 2-5：块中的字节数

版本号通常是相同的，特别是对于标准/必需的块，但对于特殊的专有块它们可以不同。实际引用为文件版本号*的*版本号似乎是`FxdParams`块中的版本号。

## gen 参数块

1.x 版本和 2.x 版本的格式略有不同。我将首先描述较新的 2.x 版本。

通用参数块以“GenParams\0”标题（字符串后跟终止“\0”字符）开头，然后是两个字节，表示语言（EN 表示英语）。其后是以下字段（在下文中，所有字符串都包含终止字符“\0”，除非另有说明）：

1. 电缆 ID：字符串
2. 光纤ID：字符串
3. 光纤类型：2字节无符号整数
4. 波长：2字节无符号整数
5. 位置 A（起始位置）：字符串
6. 位置 B（结束位置）：字符串
7. 电缆代码（或光纤类型）：字符串
8. 构建条件：2 字节字符（没有终止 '\0'）
9. 未知字段：8 字节
10. 运算符：字符串
11. 评论：字符串

电缆代码字段（第 7 字段）的解释似乎因供应商而异，有些供应商将其用作光纤类型。

光纤类型（第 3 个字段）是一个整数，表示光纤的类型。编码如下（详见[此处](http://www.ciscopress.com/articles/article.asp?p=170740&seqNum=7)）：

- 651：ITU-T G.651（多模光纤）
- 652：ITU-T G.652（标准单模光纤）
- 653：ITU-T G.653（色散位移光纤）
- 654：ITU-T G.654（1550nm损耗最小光纤）
- 655：ITU-T G.655（非零色散位移光纤）

波长（第 4 场）被编码为波长的 10 倍。因此 13100 表示 1310.0nm。但是，我看到的情况（在较旧的 1.x 格式文件中）相差 10 倍（对于 1310nm 显示 1310）。我无法确定规则是什么，但较新的 2.x 格式文件都具有 10 的因子。

构建条件（第 8 个字段）由两个字节的字符组成。编码如下：

- BC：竣工
- CC：当前
- RC：修复后的
- OT：其他

字符串字段可能包含换行符或回车符。

1.x 版本的格式类似，但它没有“GenParams\0”标头，并且缺少光纤类型（第 3 个字段）。据我所知，1.x 版本格式中没有光纤类型的编码。

## sup 参数块

供应商参数块以 2.x 版本格式的“SupParams\0”字符串开头；此标头在 1.x 版本格式中不存在。2.x版本格式的供应商参数块中的字段如下（都是以'\0'字符结尾的字符串）：

1. 供应商名称
2. OTDR 名称
3. OTDR 序列号
4. 模块名称
5. 模块序列号
6. 软件版本
7. 其他

## fxd 参数块

固定参数块以 2.x 版本格式的 'FxdParams\0' 字符串开头；此标头在 1.x 版本格式中不存在。

2.x 版本格式的字段如下（除非另有说明，均为无符号整数）：

- 0-3：日期/时间：整数，4字节
- 4-5：未知：2字节
- 6-7：波长：整数，2字节
- 8-17：未知：10 字节
- 18-19：脉冲宽度：2字节
- 20-23：距离间距：4字节
- 24-27：跟踪中的数据点数：4 字节
- 28-31：折射率：4字节
- 32-33：后向散射系数：2字节
- 34-37：平均数：4字节
- 38-41：范围：4 个字节
- 42-57：未知：16 字节
- 58-59：丢失阈值：2字节
- 60-61：反射阈值：2字节
- 62-63：传输结束阈值：2字节
- 64-65：跟踪类型：2 个**字符**
- 66-81：未知：16 字节

日期/时间字段是一个 4 字节无符号整数，它是[Unix（或 POSIX）时间](https://en.wikipedia.org/wiki/Unix_time)，是自 1970 年 1 月 1 日 00:00:00 UTC 以来经过的秒数。它后面的两个字节可能与时区有关（在某些情况下，免费 OTDR 阅读器显示的时间与我通过将其解释为 Unix 时间得到的时间相差一小时），但到目前为止我还无法确定它是如何编码。

波长被编码为一个无符号整数，它是波长的 10 倍，以纳米为单位（类似于通用参数块中的前一个波长字段）。

脉冲宽度是以纳秒为单位的无符号整数。

距离间距是一个无符号整数。要将其转换为米，请乘以 2×10 -6。然而，这个数字需要通过考虑折射率来调整，这将在后面解释。

折射率是一个无符号整数，是折射率 (IOR) 值的10 6倍。

后向散射系数是一个无符号整数。将整数乘以**-0.1**得到*dB*。

范围是无符号整数。要将其转换为*公里*，请乘以 10 -6。但是，与距离间距类似，这个数字需要通过考虑折射率来调整，这将在后面解释。

损耗、反射和终止终止 (EOT) 阈值是用于确定“事件”之一何时发生的指定值。它们是无符号整数。要将整数转换为 dB 值，请将损耗和 EOT 阈值乘以 0.001，并将反射值乘以 -0.001。

跟踪类型由两个字符表示。这些都是：

- *ST* : 标准迹线
- *RT*：反向跟踪
- *DT* : 差异轨迹
- *射频*：参考

1.x 版本的格式类似，但没有 2.x 版本中的某些字段。他们是：

- 0-3：日期/时间：整数，4字节
- 4-5：未知：2字节
- 6-7：波长：整数，2字节
- 8-13：未知：6 字节
- 14-15：脉冲宽度：2字节
- 16-19：距离间距：4字节
- 20-23：跟踪中的数据点数：4 字节
- 24-27：折射率：4字节
- 28-29：后向散射系数：2字节
- 30-33：平均数：4字节
- 34-37：范围：4 个字节
- 38-47：未知：10 个字节
- 48-49：丢失阈值：2字节
- 50-51：反射阈值：2字节
- 52-53：传输结束阈值：2字节

对于 1.x 版本，距离间距的处理方式相同。范围类似，但乘以 2×10 -5以转换为公里。1.x 版本中没有跟踪类型编码。

我见过范围值与距离间距和数据点数量不一致的情况。更安全的选择似乎是忽略范围值并根据距离间距和数据点数自行计算。（轨迹数据是等距离的。）但是，距离间隔和范围值需要通过考虑折射率来调整。显然，给出的值是针对光在特定介质中传播的距离——而不是在真空中。“真实”距离（由其他 OTDR SOR 文件阅读器显示）通过以下公式计算：

```
  (real/displayed distance) = (raw distance) × 1.498962239 / (refractive index)
```

通过将各种 OTDR SOR 文件读取器的输出与从 SOR 文件中提取的原始/原始值进行比较，推断（猜测）了幻数 1.498962239。我还没有发现这个幻数（看起来像一个折射率值）是从哪里来的，并且根据这个比例计算的距离与各种 OTDR SOR 文件读取器的值不一致，直到所有小数点。但是，在我检查过的所有情况下，这些值都在几分之一米之内。

关于范围和距离间距之间的关系：您会假设范围应该是距离间距乘以数据点数*减一*，但各种 OTDR SOR 文件读取器和写入器似乎乘以数据点数（即关闭一个）。

## 关键事件块

按键事件块以 2.x 版本格式的 'KeyEvents\0' 字符串开头；此标头在 1.x 版本格式中不存在。1.x 版本和 2.x 版本的格式略有不同。我将从 2.x 版本开始：

标头后面的前两个字节是一个无符号整数，它是事件的总数。每个事件都是一个固定的 42 字节记录，后跟一个以“\0”结尾的注释字符串（可能为空）。固定的 42 字节如下：

- 00-01：事件编号（1、2、3等）；2 个字节，无符号整数
- 02-05：未调整的距离；4 字节，无符号整数
- 06-07：坡度；2 个字节，有符号整数
- 08-09：接头损耗；2 个字节，有符号整数
- 10-13：反射损耗；4 个字节，有符号整数
- 14-21：事件类型：8个字符
- 22-29：segment 1：8字节（后面有细节）
- 30-37：第 2 段：8 个字节（详细信息如下）
- 38-41：未知：4 字节

事件编号计数从 1 开始。距离表示为无符号整数，其处理类似于固定参数块中的距离：

```
  (real/displayed distance in kilometers) = (integer value) × 2× 10-5 × 1.498962239 / (refractive index)
```

斜率、熔接损耗、反射损耗都是有*符号*整数，乘以0.001就变成dB/km（斜率）和dB。

事件类型由**nx 9999LS**形式的字符串表示，其中*n*和*x*是单个字符。*x*似乎代表（或与之相关）添加或声明事件的“模式”。什么时候

- *x*为'A'，为手动模式，否则为自动模式。
- *x*可以是字符“E”、“F”、“M”或“D”，但我没有发现它们的含义，除了“E”似乎表示光纤的末端。

*n*字符是一个数字：0、1 或 2：0 是失去或获得权力；1是反射，2表示是“多重事件”。

两个段（段 1 和段 2）对与事件相关的位置进行编码。每个段为 8 字节宽，分为两部分。段 2 的前 4 字节整数表示事件结束位置。段 2 的第二个 4 字节整数表示*下一个*事件的开始位置。在我见过的所有示例中，事件记录的第 2 段与它后面的事件记录的第 1 段相同，因此第 1 段只是事件结束和下一个事件开始的重复*上一个*事件的位置。整数到公里的转换遵循与事件的距离编码相同的公式。

所有事件记录的末尾是 22 个字节。这些编码如下：

- 00-03：总损失：2字节，无符号整数
- 04-07：光纤起始位置：4字节，有符号整数
- 08-11：光纤长度：4字节，无符号整数
- 12-13：光回损（ORL）：2字节，无符号整数
- 14-17：复制04-07（光纤起始位置）
- 18-21：复制 08-11（光纤长度）

总损耗整数和 ORL 值乘以 0.001 变为 dB。光纤起始位置和光纤长度的处理方式与之前相同，即：

```
  (real/displayed distance in kilometers) = (integer value) × 2× 10-5 × 1.498962239 / (refractive index)
```

请注意，光纤起始位置可以是负数。在我看到的所有示例中，最后 8 个字节只是光纤起始位置和光纤长度的副本。

1.x 版的格式类似，但每个事件记录都是固定的 22 字节加上一个以 '\0' 结尾的注释字符串：

- 00-01：事件编号（1、2、3等）；2 个字节，无符号整数
- 02-05：未调整的距离；4 字节，无符号整数
- 06-07：坡度；2 个字节，有符号整数
- 08-09：接头损耗；2 个字节，有符号整数
- 10-13：反射损耗；4 个字节，有符号整数
- 14-21：事件类型：8个字符

唯一的区别是没有两个段信息。版本 1.x 格式中的尾随 22 字节似乎与 2.x 版本相同，但在我研究的示例中，光纤起始位置的数字不匹配或不合理。

## 数据点块

我们终于来到了对轨迹曲线本身进行编码的数据点块。与其他块类似，该块以 2.x 版本格式的标头字符串“DataPts\0”开头，但 1.x 版本格式中没有标头。1.x 版本和 2.x 版本的格式相同。

在标头（如果适用）之后，数据点块以 12 个字节开始。前 4 个字节是一个无符号整数，它是数据点的数量（这将与来自固定参数块的数据点的数量相同）。接下来是 2 个字节，其用途未知。接下来的 4 个字节是数字数据点的重复，然后是另外 2 个字节，看起来总是与前面神秘的 2 个字节相同。

在最初的 12 字节之后，是真正的数据。每个数据点是一个 2 字节的无符号整数。乘以 -0.001 将值转换为 dB（将所有值转换为零或负）。不同的 OTDR SOR 文件阅读器对数据的偏移量不同；一些偏移数据，使最高读数为 0 dB。其他人添加偏移以使最小读数为 0 dB。

数据点按固定参数块中指定的“距离间距”值等间距（在使用折射率值调整后）。可以应用在关键事件块中指定的“光纤起始位置”值，但一些 OTDR SOF 文件阅读器不这样做。

公开的提示表明，可能会对跟踪曲线应用一个额外的比例因子（因为 2 个字节只能为您提供最大 65.535 dB 的动态范围，这可能还不够）。但尚不清楚这个比例因子来自哪里。最初的 12 字节段中未知的 2 字节似乎不是那个比例因子，而且我还没有遇到一个 SOR 文件，即比例因子。

## 校验和块

校验和块也以 2.x 格式的“Cksum\0”标头开头，而在 1.x 格式中不存在。校验和值本身是 2 个字节（16 位）。计算校验和的算法使用特定的 16 位 CRC（循环冗余校验）算法（或函数）。对于不熟悉 CRC 算法的读者，请参阅 Ross N. Williams (1993) 的优秀文章[A Painless Guide to CRC Error Detection Algorithms](https://www.zlib.net/crc_v3.txt)**CRC-16/CCITT-FALSE**[目录，请参阅 16 位参数化 CRC 算法目录](http://reveng.sourceforge.net/crc-catalogue/16.htm)

> 有关 CRC 函数的 Perl 实现，请参阅[Digest::CRC](http://search.cpan.org/~olimaul/Digest-CRC-0.21/lib/Digest/CRC.pm)模块；对于 Python 实现，请参阅[crcmod](http://crcmod.sourceforge.net/)模块。

*由于 CRC-16 算法有几种变体，并且名称和确切定义有些混淆，我将按照Painless Guide*文档中的约定在下面拼出确切的参数：

- 宽度：`16`
- 聚：`0x1021`
- 在里面：`0xFFFF`
- 参考：`False`
- 参考输出：`False`
- 异或输出：`0x0000`
- 检查：（`**0x29B1**`输入字符串为“123456789”）

最后一项有助于检查您使用的实现是否正确：当给定字符串“12345789”时，校验和应为“0x29B1”。

计算校验和的确切算法（对于版本 1.x 和 2.x）如下：将文件的整个内容，包括 'Cksum\0' 标头，作为一个巨大的二进制字符串，并计算校验和在这个字符串上。校验和将是两个字节（16 位），然后附加到文件中（在“Cksum\0”标头之后）。但是，这两个字节需要*交换*，因为 SOR 文件中的约定是以小端字节顺序存储数字。例如，如果校验和为 0xD680，则 SOR 文件的最后两个字节为 0x80、0xD6。

事实证明，这在某些方面非常尴尬。CRC 算法的一个非常有趣的特性是，如果您将 16 位校验和的两个字节附加到文件（或字符串），然后对其运行 CRC 函数，校验和将为零！但这仅在校验和以大端字节顺序附加时才有效。换句话说，取 SOR 文件的最后两个字节，交换它们，然后在其上运行校验和功能。如果校验和为零，则一切正常（或者更确切地说，很*可能*是正常的；CRC 错误检测代码将检测到大多数备用错误，但它毕竟没有检测到*所有*错误）。如果不需要两个校验和字节的字节交换，那就太好了。

最后提醒一句：我已经针对许多版本的 1.x 和 2.x 文件检查了这个 CRC-16 算法；除了来自一个特定供应商的两个示例文件之外，所有这些文件都已检出，因此我相信该算法是正确的。

## 结束语

SOR 格式还有几个部分我仍然不知道，但我相信大部分编码方案正如我在本文中所描述的那样，并且*大部分*[pubOTDR](https://github.com/sid5432/pubOTDR)